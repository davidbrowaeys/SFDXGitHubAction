name: Salesforce Project CI/CD

on:
  pull_request:
    # Triggers on PRs targeting develop or any release branch
    branches:
      - develop
      - 'release/**'
  push:
    # Triggers on Pushes directly to develop or any release branch
    branches:
      - develop
      - 'release/**'

jobs:
  # --- 1. Determine which environments need validation/deployment ---
  determine_targets:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_targets.outputs.targets }}
      
    steps:
      - name: ðŸ” Determine Target Environment & Mode
        id: set_targets
        run: |
          You are proposing a dictionary (or hash map) structure where the environment name is the key and the configuration is the value. This is a great alternative to the array structure!

While GitHub's matrix strategy traditionally consumes a JSON array (e.g., [{"env": "QA"}, {"env": "QA1"}]), it can also consume a JSON object (a dictionary) where the keys are the matrix axes.

The structure you suggested:

JSON

{
    "QA": { "auth_secret": "QA_AUTH_URL", "check_only": "true" },
    "QA1": { "auth_secret": "QA1_AUTH_URL", "check_only": "true" },
    // ...
}
This structure requires a slight change in how the determine_targets script builds the JSON and how the downstream job consumes the matrix.

âœ… The Refined Approach: Using a Dictionary as the Matrix
This approach uses your desired dictionary format, which is very clear and clean.

1. New Job: Determine Deployment Targets (Dictionary Structure)
The shell script is much simpler, as we just add properties to a single dictionary object ({}) instead of appending to an array ([]).

YAML

jobs:
  # --- 1. Determine which environments need validation/deployment ---
  determine_targets:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_targets.outputs.targets }}
      
    steps:
      - name: ðŸ” Determine Target Environment & Mode
        id: set_targets
        run: |
          # --- Define Variables from GitHub Context ---
          EVENT_NAME="${{ github.event_name }}"
          BASE_REF="${{ github.base_ref }}"
          REF="${{ github.ref }}"
          
          # Initialize $targets as a JSON object (dictionary)
          targets="{}"
          
          # --- Determine Check-Only Mode ---
          CHECK_ONLY_MODE="false"
          if [ "$EVENT_NAME" = "pull_request" ]; then
            CHECK_ONLY_MODE="true"
          fi
          
          JQ_OPTIONS='-c --arg checkmode "$CHECK_ONLY_MODE"'
          
          echo "Deployment Mode: Check-Only = $CHECK_ONLY_MODE"
          
          # --- SCENARIO A: Target is 'develop' (QA/SIT environment) ---
          if [ "$BASE_REF" = "develop" ] || [ "$REF" = "refs/heads/develop" ]; then
            echo "Target branch is 'develop'. Scheduling QA validation/deployment."
            
            # Use jq to add a new key-value pair to the dictionary: .QA = { ... }
            targets=$(echo "$targets" | jq $JQ_OPTIONS '.QA = { 
              "auth_secret": "QA_AUTH_URL", 
              "check_only": $checkmode 
            }')
            
          # --- SCENARIO B: Target is a 'release/**' branch (QA1/QA2) ---
          elif [[ "$BASE_REF" =~ ^release/ ]] || [[ "$REF" =~ refs/heads/release/ ]]; then
            echo "Target branch is a 'release/**' branch. Targeting QA environments."

            # QA1 Target
            targets=$(echo "$targets" | jq $JQ_OPTIONS '.QA1 = { 
              "auth_secret": "QA1_AUTH_URL", 
              "check_only": $checkmode 
            }')
            
            # QA2 Target
            targets=$(echo "$targets" | jq $JQ_OPTIONS '.QA2 = { 
              "auth_secret": "QA2_AUTH_URL", 
              "check_only": $checkmode 
            }')

          else
            echo "::notice::Workflow triggered by event/branch that does not require deployment. Exiting."
          fi
          
          # Check if the targets object is empty
          if [ "$targets" = "{}" ]; then
            echo "::notice::No relevant deployment conditions met. Terminating workflow early."
            # The strategy job will fail if it receives an empty object (or exit 1 here)
            echo "targets={}" >> $GITHUB_OUTPUT
            exit 1
          fi

          # 1. Use 'jq -c' to output the JSON compacted to a single line.
          COMPACT_TARGETS=$(echo "$targets" | jq -c '.')
          
          echo "Targets JSON (Compacted): $COMPACT_TARGETS"
          
          # 2. Output the single-line string directly to GITHUB_OUTPUT.
          echo "targets=$COMPACT_TARGETS" >> $GITHUB_OUTPUT
        shell: bash

  # --- 2. Main Job: Execute Deployments Dynamically (Matrix) ---
  qa_validation_pr:
    name: ðŸš€ Deploy to ${{ matrix.target.target_env }} (${{ matrix.target.check_only == 'true' && 'Validation' || 'Deployment' }})
    needs: determine_targets
    
    strategy:
      fail-fast: false
      # CRITICAL: This pulls the list of targets (SIT, QA1, QA2) from the previous job.
      matrix:
        target: ${{ fromJson(needs.determine_targets.outputs.matrix) }}
    
    # You must have jq installed in this image or add a setup step if you used a base image.
    # Since this is a reusable workflow, jq is likely not needed here.
    
    uses: davidbrowaeys/SafireForGitHub/.github/workflows/continuous-integration.yml@main
    
    with:
      target-env: ${{ matrix.target.target_env }}
      deployment-mode: 'DELTA'
      
      # Use the dynamic 'check_only' value from the matrix
      check-only: ${{ matrix.target.check_only == 'true' }}
      
      # Run scanner only for validation runs
      run-code-scanner: ${{ matrix.target.check_only == 'true' }}
      
    secrets:
      # Dynamically fetch the correct secret (SIT_AUTH_URL, QA1_AUTH_URL, etc.)
      AUTH_URL: ${{ secrets[matrix.target.auth_secret] }}
